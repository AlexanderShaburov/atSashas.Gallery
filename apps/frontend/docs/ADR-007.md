# ADR-007: Form Architecture, Validation Strategy, and State Flow for Catalog Editor

**Status:** Accepted
**Date:** 2025-11-01
**Authors:** Alexander Shaburov & team
**Context:** SashaGallery Admin – `CatalogEditorPage` → `SingleItemEditor` → `CreateForm`
**Scope:** Client-side architecture for creating/editing `ArtItem` entries

---

## 1) Problem Statement

Early iterations relied on deep prop-drilling (passing many props through intermediate components) and mixed validation concerns (field errors, form validity, save logic) across multiple layers. This produced complexity, inconsistent UX, and brittle code.

We need a clean, predictable architecture that:

- Avoids prop-drilling.
- Separates responsibilities clearly.
- Supports incremental (multi-layer) validation.
- Keeps UX sane (no error spam before user interaction).
- Is easy to test and evolve.

---

## 2) Decision

We adopt a **three-layer validation** strategy and a **context-driven state flow**:

### A. Three-Layer Validation

1. **Field-level (UI) validation — inside `CreateForm`:**
    - Purpose: UX only.
    - Show errors **only for fields the user has interacted with** (`touched`).
    - No global knowledge required; no cross-field policies enforced here.
    - Exposes an **imperative method** `revealErrors()` to show all local errors on demand (e.g., after a failed Save).

2. **Form-level (client) validation — inside `CatalogEditorPage`:**
    - Purpose: gate for Save.
    - Minimal rule set for now (e.g., **ID** and **selected image** required).
    - Performs **sanitization** (coerce/strip invalid shapes to safe defaults) before building the payload.
    - No field-by-field error distribution; a single, clear message is shown if minimal rules fail.

3. **Domain/server validation — on the API side:**
    - Purpose: contract & semantics.
    - Validates the JSON payload (schema + domain rules).
    - Returns structured errors; client surfaces a clear message.
    - Server is the final authority.

### B. Context for Editor Session

- Introduce `EditorSessionContext` that encapsulates **all editor session state and actions**:
    - `formValues`, `setFormValues`
    - `selectedThumbId`
    - `isDirty`, `isValid`, `saving`
    - `onSave`, `onCancel`, `onBack`

- The context **exists only when an item is being edited** (i.e., provider is rendered in the editor branch). On `Back/Cancel/Save`, the provider unmounts, **resetting session state naturally**.

This removes prop-drilling and keeps `SingleItemEditor` / `CreateForm` lean.

---

## 3) Rationale

- **Single source of truth** for session state improves predictability.
- **Unmount = reset** yields a natural lifecycle; no manual “clear all” gymnastics.
- **Separation of concerns**:
    - `CreateForm` cares about _local UX feedback_.
    - `CatalogEditorPage` controls _save flow_ and _minimal gating_.
    - Server guards _domain correctness_.

- **Extensibility**: Later we can add schema validation (e.g., Zod) at the build/API boundary without disturbing UI.

---

## 4) Consequences

**Positive**

- No more prop caravans.
- Cleaner toolbar logic (`Save/Cancel/Back`) driven by `isDirty/isValid/saving`.
- Easier to test: UI vs. save-flow vs. server behaviors are isolated.

**Trade-offs**

- Slight indirection: components read from context rather than props.
- Two validation “views” (UI vs. form-gate) require discipline in messaging (by design).

---

## 5) Interfaces (Sketches)

### 5.1 Editor Session Context

```tsx
// editor-session.tsx
import { createContext, useContext } from 'react';
import type { FormValues } from '@/features/admin/ui/CreateForm/CreateForm';

export type EditorSession = {
    formValues: FormValues | null;
    setFormValues: (v: FormValues | null) => void;

    selectedThumbId: string;
    saving: boolean;
    isDirty: boolean;
    isValid: boolean;

    onSave: () => Promise<void> | void;
    onCancel: () => void;
    onBack: () => void;
};

const EditorSessionContext = createContext<EditorSession | null>(null);

export function useEditorSession() {
    const ctx = useContext(EditorSessionContext);
    if (!ctx) throw new Error('useEditorSession must be used within provider');
    return ctx;
}

export default EditorSessionContext;
```

### 5.2 Provider Usage (in `CatalogEditorPage`)

```tsx
// inside the "editor branch" only (when a thumb is selected)
<EditorSessionContext.Provider
    value={{
        formValues,
        setFormValues,
        selectedThumbId: selected,
        saving,
        isDirty,
        isValid,
        onSave: handleSave,
        onCancel: handleCancel,
        onBack: handleBack,
    }}
>
    <SingleItemEditor
        thumb={activeThumb.current!}
        FormComponent={CreateForm}
        // formProps may remain only for static data like techniques/seriesOptions
    />
</EditorSessionContext.Provider>
```

> On `Back/Cancel/Save` we call `setSelected(null)`; the provider unmounts and resets the session.

### 5.3 `CreateForm` Local UX Validation

- Tracks `touched` locally.
- Shows per-field messages only if `touched[field]` is true.
- Exposes `revealErrors()` via `forwardRef` / `useImperativeHandle` to reveal all field errors when the parent Save fails.

```tsx
// CreateForm.tsx (sketch)
export type CreateFormHandle = { revealErrors: () => void };

const CreateForm = forwardRef<CreateFormHandle, Props>((props, ref) => {
    const [touched, setTouched] = useState<Record<string, boolean>>({});
    useImperativeHandle(ref, () => ({
        revealErrors: () => setTouched((t) => ({ ...t /* mark critical fields */ })),
    }));
    // render inputs; onBlur -> setTouched({ ...t, field: true })
});
```

Parent (page) can call `formRef.current?.revealErrors()` if form-level validation fails.

---

## 6) Minimal Client Validation & Sanitization

- **Minimal gate** (current phase): require **ID** and **selected image**.
- **Sanitizer**: coerce/strip invalid shapes to safe defaults before build.

```tsx
function isMinimalValid(form: FormValues | null, selectedThumbId: string | null): boolean {
    const okId = typeof form?.id === 'string' && form.id.trim().length > 0;
    const okImage = !!(selectedThumbId && selectedThumbId.trim());
    return okId && okImage;
}

function sanitizeForm(v: FormValues): FormValues {
    const safe = { ...v };
    // trim id
    if (typeof safe.id === 'string') safe.id = safe.id.trim();
    // normalize optional shapes to undefined if malformed...
    return safe;
}
```

---

## 7) Server-Side Validation (Contract)

- The API validates payload shape and domain semantics.
- Returns structured errors.
- Client surfaces a concise message (optionally mapping field hints back to UI later).

Future-proofing: adopt a schema (e.g., Zod) in a shared package or server-only, and validate `ArtItemJSON`.

---

## 8) Testing Strategy

- **Unit (UI):** `CreateForm` renders field errors only after touch; `revealErrors()` shows them all.
- **Unit (Page):** `handleSave` blocks when `!isMinimalValid`, calls `sanitizeForm`, builds payload, handles success/failure paths.
- **Integration:** end-to-end create flow with selected thumb → save → catalog updated.
- **API contract:** payload that fails server schema returns 4xx with structured errors.

---

## 9) Migration Plan (Phased)

**Phase 1 — Context & Minimal Gate (Now)**

- Add `EditorSessionContext`.
- Move session state/actions into provider (only in editor branch).
- Implement minimal `isMinimalValid` (ID + image) and `sanitizeForm`.
- Keep UI validation local to `CreateForm` (touched), no prop-drilling.
- Wire Save/Cancel/Back.

**Phase 2 — Builder & Schema**

- Add `buildArtItemJSON(formValues, selectedThumbId)` at the page boundary.
- Optionally introduce Zod/Yup to validate the built payload before POST.

**Phase 3 — Server Contract**

- Enforce schema on the server; return structured errors.
- Add client mapping for top-level error banner, optionally per-field hints later.

**Phase 4 — Enhancements (Optional)**

- Replace any remaining pass-through props with context consumers.
- Add autosave drafts or “leave with unsaved changes?” prompts based on `isDirty`.

---

## 10) Non-Goals (for now)

- Full per-field client validation of all domain rules.
- Complex cross-field logic in the UI.
- Bi-directional syncing of server errors to inline UI messages (can be added later).

---

## 11) Summary

We formalize a **three-layer validation** model and a **context-driven editor session**.
This eliminates prop-drilling, clarifies responsibilities, and provides a stable base to incrementally tighten validation at the build/server boundary without compromising UX.

---

## Next Steps (Checklist)

1. **Create** `EditorSessionContext` and wrap the editor branch only.
2. **Move** session state (`formValues`, `isDirty`, `isValid`, `saving`, handlers) into the provider value.
3. **Update** `SingleItemEditor` / `CreateForm` to read from context (or add a thin `CreateFormWithSession` wrapper).
4. **Implement** `isMinimalValid()` and `sanitizeForm()` in `CatalogEditorPage`.
5. **Expose** `CreateForm.revealErrors()` (imperative handle), and call it on failed Save (optional).
6. **Add** `buildArtItemJSON()` at the page boundary; keep server as final validator.
7. **Document** the contract for server errors and how the client surfaces them.

— End of ADR —

```bash
features/
  editor-session/
    index.ts
    model/
      context.tsx               // createContext + useEditorSession
      provider.tsx              // <EditorSessionProvider> со стейтами
      types.ts                  // сигнатуры session value
    lib/
      dirty-snapshot.ts         // deepEqual + normalizeForCompare
      validate-minimal.ts
      sanitize-form.ts
      build-art-item-json.ts
    ui/                         // (опционально) общие элементы тулбара
      EditorToolbar.tsx

pages/
  admin/
    CatalogEditorPage/
      page.tsx
      // берёт Provider из features/editor-session
```

import type { ArtItemJSON, ImagesJSON } from '@/entities/art';
import { useEffect, useMemo, useState } from 'react';

import { FullPath } from '@/entities/art/images';
import { Availability, ISODate } from '@/entities/common';
import { HOPPER_LIST_URL, UPDATE_CATALOG /*, CATALOG_META_URL?*/ } from '../api';
import './catalogPage.css';

import HopperGrid from './HopperGrid';
import DraftsColumn from './DraftsColumn';
import ItemForm from './ItemForm';

type Currency = 'EUR' | 'USD' | 'ILS' | 'GBP';
type Unit = 'cm' | 'mm' | 'in';

interface HopperItem {
  name: string;
  url: string;
  previewUrl?: string;
  size?: number;
  mtime?: string;
}

interface MetaData {
  techniques: string[];
  series: string[];
  tags: string[];
  currencies: Currency[];
  units: Unit[];
  availability: Availability[];
}

const DEFAULT_META: MetaData = {
  techniques: [],
  series: [],
  tags: [],
  currencies: ['EUR', 'USD', 'ILS', 'GBP'],
  units: ['cm', 'mm', 'in'],
  availability: ['available', 'reserved', 'sold', 'not_for_sale'],
};

export default function CatalogPage() {
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [items, setItems] = useState<HopperItem[]>([]);
  const [q, setQ] = useState('');
  const [focusedId, setFocusedId] = useState<string | null>(null);

  // ключ: draftId, значение: драфт
  const [drafts, setDrafts] = useState<Record<string, ArtItemJSON>>({});
  const [meta, setMeta] = useState<MetaData>(DEFAULT_META);

  const fmtDate = (d = new Date()) => d.toISOString().slice(0, 10) as ISODate;
  const newId = () =>
    crypto?.randomUUID
      ? crypto.randomUUID()
      : `${Date.now().toString(36)}-${Math.random().toString(36).slice(2)}`;

  useEffect(() => {
    const run = async () => {
      try {
        setLoading(true);
        setError(null);
        const resp = await fetch(HOPPER_LIST_URL, { credentials: 'include' });
        if (!resp.ok) throw new Error(`Hopper list failed: ${resp.status}`);
        const data = (await resp.json()) as HopperItem[];
        setItems(data);

        // Если есть отдельная ручка метаданных — подтяни:
        // const m = await (await fetch(CATALOG_META_URL, { credentials: 'include' })).json();
        // setMeta({ ...DEFAULT_META, ...m });

      } catch (e: any) {
        setError(e.message || String(e));
      } finally {
        setLoading(false);
      }
    };
    run();
  }, []);

  const filtered = useMemo(() => {
    const s = q.trim().toLowerCase();
    if (!s) return items;
    return items.filter(it => (it.name || '').toLowerCase().includes(s));
  }, [items, q]);

  const buildDraft = (it: HopperItem): ArtItemJSON => {
    const id = newId();
    const baseNameNoExt = it.name.replace(/\.[^.]+$/, '');
    return {
      id,
      title: { ru: baseNameNoExt },
      dateCreated: fmtDate(),
      techniques: [],
      price: null,
      availability: 'available',
      series: null,
      tags: [],
      notes: null,
      images: { full: it.url as FullPath } as ImagesJSON,
      dimensions: { width: 0, height: 0, unit: 'cm' },
    };
  };

  // Клик по превью
  const onPick = (it: HopperItem) => {
    // Ищем уже созданный драфт по этому url (чтобы не плодить дубликаты)
    const existingEntry = Object.values(drafts).find(d => (d.images as any)?.full === it.url);
    if (existingEntry) {
      setFocusedId(existingEntry.id!);
      return;
    }
    const d = buildDraft(it);
    setDrafts(prev => ({ ...prev, [d.id!]: d }));
    setFocusedId(d.id!);
  };

  const updateDraft = (id: string, patch: Partial<ArtItemJSON>) =>
    setDrafts(prev => {
      const cur = prev[id];
      return cur ? { ...prev, [id]: { ...cur, ...patch } } : prev;
    });

  const removeDraft = (id: string) =>
    setDrafts(prev => {
      const copy = { ...prev };
      delete copy[id];
      if (focusedId === id) setFocusedId(null);
      return copy;
    });

  const saveOne = async (id: string) => {
    const draft = drafts[id];
    if (!draft) return;
    setSaving(true);
    try {
      const resp = await fetch(UPDATE_CATALOG, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(draft),
      });
      if (!resp.ok) throw new Error(`Save failed: ${resp.status}`);
      // Можно пометить драфт как сохранённый/очистить/оставить
    } catch (e: any) {
      setError(e.message || String(e));
    } finally {
      setSaving(false);
    }
  };

  const saveAll = async () => {
    setSaving(true);
    try {
      const all = Object.values(drafts);
      await Promise.all(
        all.map(d =>
          fetch(UPDATE_CATALOG, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify(d),
          }),
        ),
      );
    } catch (e: any) {
      setError(e.message || String(e));
    } finally {
      setSaving(false);
    }
  };

  if (loading) return <div className="empty">Загружаю превью…</div>;
  if (error) {
    return (
      <div className="empty" style={{ borderColor: 'var(--danger)', color: 'var(--danger)' }}>
        Ошибка: {error}
      </div>
    );
  }

  return (
    <div className="catalog-grid">
      <aside className="hopper-pane">
        <div className="hopper-tools">
          <input
            className="form-input"
            placeholder="Поиск…"
            value={q}
            onChange={(e) => setQ(e.target.value)}
          />
        </div>
        <HopperGrid items={filtered} onPick={onPick} />
      </aside>

      <section className="drafts-pane">
        <div className="drafts-header">
          <div>Выбрано: {Object.keys(drafts).length}</div>
          <div className="drafts-actions">
            <button className="btn" onClick={saveAll} disabled={saving || !Object.keys(drafts).length}>
              {saving ? 'Сохраняю…' : 'Сохранить все'}
            </button>
          </div>
        </div>

        <DraftsColumn
          drafts={drafts}
          meta={meta}
          focusedId={focusedId}
          setFocusedId={setFocusedId}
          onUpdate={updateDraft}
          onRemove={removeDraft}
          onSave={saveOne}
        />

        {focusedId && drafts[focusedId] && (
          <div className="form-panel">
            <ItemForm
              draft={drafts[focusedId]}
              meta={meta}
              onChange={(patch) => updateDraft(focusedId, patch)}
              onSave={() => saveOne(focusedId)}
            />
          </div>
        )}
      </section>
    </div>
  );
}
